function [ LTS, OneLTS ] = GenerateLTS(mode)
%
% Генерирует часть преамбулы (long symbols) во временной области
% согласно стандарту 802.11a
%
% См. "IEEE Std 802.11-2012", стр. 1594, 2541
% См. "IEEE Std 802.11-2016", стр. 2289, 3317
%
% in:
%   @mode - 'Tx' или 'Rx'
%
%
% Если режим 'Tx', то данная функция генерирует 161 комлпексных отсчётов
% (именно так указано в стандарте):
%   | удлиннённый_GI[32] |  +  | 2_LTS[64+64] |  +  | 1_отсчёт[1] |
%
% Также ПРИСУТСТВУЕТ умножение на оконную функцию, которая в цифровом виде имеет вид:
%
%        | 0.5   k = 0
% w[k] = | 1     1 <= k <= 159
%        | 0.5   k = 160
%
% // Первый отсчёт (k=0) перекрывается (суммируется) с последним отсчётом (k=160)
% // предыдущего OFDM-символа (STS)
%
%
% Если режим 'Rx', то данная функция генерирует 128 комлпексных отсчётов без умножения
% на оконную функцию, т.е. на выходе получаем 2 одинаковых LTS по 64 комплексных
% отсчёта каждый (используем на приёмной стороне во время корреляции)

        % L_-26_26
        L = [ 1,  1, -1, -1,  1,  1, -1,  1, -1,  1, ...
              1,  1,  1,  1,  1, -1, -1,  1,  1, -1, ...
              1, -1,  1,  1,  1,  1, ...
              0, ...
              1, -1, -1,  1,  1, -1, ...
              1, -1,  1, -1, -1, -1, -1, -1,  1,  1, ...
             -1, -1,  1, -1,  1, -1,  1,  1,  1, 1 ];
        
        % Нормальный порядок + Nulls для IFFT блока
        L = [0, ...
             L(28 : 53), ...
             zeros(1, 11), ...
             L(1 : 26)];
     
        LTS = ifft(L);

	OneLTS = LTS;
        
	if strcmp(mode, 'Tx')

        % Расширяем до 161 отсчётов (удлиннённый_GI[32] + 2_LTS[64+64] + 1_отсчёт[1])
		% (первый отсчёт GI перекрыватся с последний отсчётом Short Symbols)
		LTS = [LTS(33 : 64), LTS, LTS, LTS(1)];

		% Умножение на оконнную функцию
		LTS(1)   = 0.5 * LTS(1);
		LTS(161) = 0.5 * LTS(161);

	else % strcmp(mode, 'Rx')

        % Расширяем до 160 отсчётов (длинный GI + 2 подряд идущих длинных символа)
        LTS = [LTS(33 : 64), LTS, LTS];

	end
        
end

